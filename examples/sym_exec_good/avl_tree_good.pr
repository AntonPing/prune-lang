datatype AVLTree where
| Node(AVLTree, Int, AVLTree) // node of (left, key, right)
| Empty // empty tree
end

datatype OptionInt where
| Some(Int)
| None
end

function insert(tree: AVLTree, x: Int) -> AVLTree
begin
    match tree with
    | Node(left, y, right) =>
        condition
        | x < y =>
            rebalance(Node(insert(left, x), y, right))
        | x > y =>
            rebalance(Node(left, y, insert(right, x)))
        | x == y =>
            tree
        end
    | Empty => Node(Empty, x, Empty)
    end
end

function get_height(tree: AVLTree) -> Int
begin
    match tree with
    | Node(left, _key, right) => 
        let left_height = get_height(left);
        let right_height = get_height(right);
        if left_height < right_height then
            right_height + 1
        else
            left_height + 1
    | Empty => 0
    end
end

function balance_factor(tree: AVLTree) -> Int
begin
    match tree with
    | Node(left, _key, right) => get_height(left) - get_height(right)
    | Empty => 0
    end
end

function rebalance(tree: AVLTree) -> AVLTree
begin
    let bf = balance_factor(tree);
    condition
    | bf >= -1 && bf <= 1 =>
        tree
    | bf <= -2 =>
        let Node(left, x, right) = tree;
        if balance_factor(right) <= 0 then
            rotate_left(tree)
        else
            rotate_left(Node(left, x, rotate_right(right)))
    | bf >= 2 =>
        let Node(left, x, right) = tree;
        if balance_factor(left) >= 0 then
            rotate_right(tree)
        else
            rotate_right(Node(rotate_left(left), x, right))
    end
end

function rotate_left(tree: AVLTree) -> AVLTree
begin
    let Node(left, key, Node(r_left, r_key, r_right)) = tree;
    Node(Node(left, key, r_left), r_key, r_right)
end

function rotate_right(tree: AVLTree) -> AVLTree
begin
    let Node(Node(l_left, l_key, l_right), key, right) = tree;
    Node(l_left, l_key, Node(l_right, key, right))
end

function is_balanced(tree: AVLTree) -> Bool
begin
    match is_balanced_help(tree) with
    | Some(_) => true 
    | None => false
    end
end

function is_balanced_help(tree: AVLTree) -> OptionInt
begin
    match tree with
    | Node(left, _, right) => 
        match (is_balanced_help(left), is_balanced_help(right)) with
        | (Some(left_height), Some(right_height)) =>
            let diff_height = left_height - right_height;
            if diff_height >= -1 && diff_height <= 1 then
                if left_height < right_height then 
                    Some(right_height + 1)
                else
                    Some(left_height + 1)
            else
                None
        | (None, _) => None
        | (_, None) => None
        end
    | Empty => Some(0)
    end
end

function is_sorted(tree: AVLTree) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        is_sorted_max(left, x) && is_sorted_min(right, x)
    | Empty => true
    end
end

function is_sorted_min(tree: AVLTree, min: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x > min &&
        is_sorted_min_max(left, min, x) && is_sorted_min(right, x)
    | Empty => true
    end
end

function is_sorted_max(tree: AVLTree, max: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x < max &&
        is_sorted_max(left, x) && is_sorted_min_max(right, x, max)
    | Empty => true
    end
end

function is_sorted_min_max(tree: AVLTree, min: Int, max: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x > min && x < max &&
        is_sorted_min_max(left, min, x) && is_sorted_min_max(right, x, max)
    | Empty => true
    end
end

function keep_sorted_and_balanced(tree: AVLTree, x: Int)
begin
    guard is_sorted(tree);
    guard is_balanced(tree);
    let res = insert(tree, x);
    guard !is_sorted(res) || !is_balanced(res);
end

query keep_sorted_and_balanced(depth_step=5, depth_limit=50, answer_limit=1)