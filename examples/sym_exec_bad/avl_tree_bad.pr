datatype AVLTree where
| Node(AVLTree, Int, AVLTree)
| Empty
end

datatype OptionInt where
| Some(Int)
| None
end

function insert(tree: AVLTree, x: Int) -> AVLTree
begin
    match tree with
    | Node(left, y, right) =>
        if @icmplt(x, y) then
            rebalance(Node(insert(left, x), y, right))
        else if @icmpgt(x, y) then
            rebalance(Node(left, y, insert(right, x)))
        else tree
    | Empty => Node(Empty, x, Empty)
    end
end

function depth(tree: AVLTree) -> Int
begin
    match tree with
    | Node(left, x, right) => 
        let l_d = depth(left);
        let r_d = depth(right);
        if @icmplt(l_d, r_d) then @iadd(r_d, 1) else @iadd(l_d, 1)
    | Empty => 0
    end
end

function balance_factor(tree: AVLTree) -> Int
begin
    match tree with
    | Node(left, x, right) => @isub(depth(left), depth(right))
    | Empty => 0
    end
end

function rebalance(tree: AVLTree) -> AVLTree
begin
    let bf = balance_factor(tree);
    if @band(@icmpge(bf, -1), @icmple(bf, 1)) then
        tree
    else if @icmpeq(bf, -2) then
        rotate_left(tree)
    else if @icmpeq(bf, 2) then
        rotate_right(tree)
    else Empty
end

function rotate_left(tree: AVLTree) -> AVLTree
begin
    match tree with
    | Node(left, x, right) => 
        match right with
        | Node(r_left, r_x, r_right) =>
            Node(Node(left, x, r_left), r_x, r_right)
        | Empty => tree
        end
    | Empty => Empty
    end
end

function rotate_right(tree: AVLTree) -> AVLTree
begin
    match tree with
    | Node(left, x, right) => 
        match left with
        | Node(l_left, l_x, l_right) =>
            Node(l_left, l_x, Node(l_right, x, right))
        | Empty => Empty
        end
    | Empty => Empty
    end
end

function is_balanced(tree: AVLTree) -> Bool
begin
    match is_balanced_help(tree) with
    | Some(d) => true 
    | None => false
    end
end

function is_balanced_help(tree: AVLTree) -> OptionInt
begin
    match tree with
    | Node(left, x, right) => 
        match is_balanced_help(left) with
        | Some(l_d) => match is_balanced_help(right) with
            | Some(r_d) => 
                let diff = @isub(l_d, r_d);
                if @band(@icmpge(diff, -1), @icmple(diff, 1)) then
                    if @icmplt(l_d, r_d) then 
                        Some(@iadd(r_d, 1))
                    else
                        Some(@iadd(l_d, 1))
                else
                    None
            | None => None
            end
        | None => None
        end
    | Empty => Some(0)
    end
end

function is_sorted(tree: AVLTree) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        @band(is_sorted_max(left, x), is_sorted_min(right, x))
    | Empty => true
    end
end

function is_sorted_min(tree: AVLTree, min: Int)  -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        @band(
            @icmpge(x, min),
            @band(is_sorted_min_max(left, min, x), is_sorted_min(right, x))
        )
    | Empty => true
    end
end

function is_sorted_max(tree: AVLTree, max: Int)  -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        @band(
            @icmple(x, max),
            @band(is_sorted_max(left, x), is_sorted_min_max(right, x, max))
        )
    | Empty => true
    end
end

function is_sorted_min_max(tree: AVLTree, min: Int, max: Int)  -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        @band(
            @band(@icmpge(x, min), @icmple(x, max)),
            @band(is_sorted_min_max(left, min, x), is_sorted_min_max(right, x, max))
        )
    | Empty => true
    end
end	

predicate keep_sorted_and_balanced(tree: AVLTree, x: Int)
begin
    fresh(res) (
        and(
            is_sorted(tree) = true,
            is_balanced(tree) = true,
            res = insert(tree, x),
            or(
                is_sorted(res) = false,
                is_balanced(res) = false,
            ),
        )
    )
end

entry keep_sorted_and_balanced(5, 1000, 5)