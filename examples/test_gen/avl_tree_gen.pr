datatype AVLTree where
| Node(AVLTree, Int, AVLTree)
| Empty
end

datatype OptionInt where
| Some(Int)
| None
end

function is_balanced(tree: AVLTree) -> Bool
begin
    match is_balanced_help(tree) with
    | Some(d) => true 
    | None => false
    end
end

function is_balanced_help(tree: AVLTree) -> OptionInt
begin
    match tree with
    | Node(left, x, right) => 
        match is_balanced_help(left) with
        | Some(l_d) => match is_balanced_help(right) with
            | Some(r_d) => 
                let diff = l_d - r_d;
                if diff >= -1 && diff <= 1 then
                    if l_d < r_d then 
                        Some(r_d + 1)
                    else
                        Some(l_d + 1)
                else
                    None
            | None => None
            end
        | None => None
        end
    | Empty => Some(0)
    end
end

function is_balanced2(tree: AVLTree) -> Unit
begin
    let d = is_balanced_help2(tree);
    ()
end

function is_balanced_help2(tree: AVLTree) -> Int
begin
    match tree with
    | Node(left, x, right) => 
        let l_d = is_balanced_help2(left);
        let r_d = is_balanced_help2(right);
        let diff = l_d - r_d;
        guard (diff >= -1 && diff <= 1) = true;
        if l_d < r_d then
            r_d + 1
        else
            l_d + 1
    | Empty => 0
    end
end

function is_sorted(tree: AVLTree) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        is_sorted_max(left, x) && is_sorted_min(right, x)
    | Empty => true
    end
end

function is_sorted_min(tree: AVLTree, min: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x > min &&
        is_sorted_min_max(left, min, x) && is_sorted_min(right, x)
    | Empty => true
    end
end

function is_sorted_max(tree: AVLTree, max: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x < max &&
        is_sorted_max(left, x) && is_sorted_min_max(right, x, max)
    | Empty => true
    end
end

function is_sorted_min_max(tree: AVLTree, min: Int, max: Int) -> Bool
begin
    match tree with
    | Node(left, x, right) =>
        x > min && x < max &&
        is_sorted_min_max(left, min, x) && is_sorted_min_max(right, x, max)
    | Empty => true
    end
end

predicate gen_sorted_balanced(tree: AVLTree)
begin
    and(
        is_sorted(tree) = true,
        is_balanced2(tree) = (),
    )
end

query gen_sorted_balanced(depth_step=5, depth_limit=200, answer_limit=30)