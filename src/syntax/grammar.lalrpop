use crate::utils::ident::Ident;
use crate::utils::intern::InternStr;
use crate::utils::lit::{LitType, LitVal};
use crate::utils::prim::Prim;
use crate::syntax::ast::*;

use std::str::FromStr;

grammar;

pub Nat: usize = <s:r"[0-9]+"> => usize::from_str(s).unwrap();
pub Int: i64 = {
    <n: Nat> => n as i64,
    "-" <n: Nat> => - (n as i64),
}
pub Float: f64 = <s:r"(-)?[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
pub Bool: bool = {
    "false" => false,
    "true" => true,
};
pub Char: char = <s:r"'.'"> => char::from_str(&s[1..2]).unwrap();

pub LId: Ident = <s:r"[_a-z][_a-zA-Z0-9]*"> => Ident::dummy(&InternStr::new(s));
pub UId: Ident = <s:r"[A-Z][_a-zA-Z0-9]*"> => Ident::dummy(&InternStr::new(s));

pub LitVal: LitVal = {
    <x: Int> => LitVal::Int(x),
    <x: Float> => LitVal::Float(x),
    <x: Char> => LitVal::Char(x),
    <x: Bool> => LitVal::Bool(x),
};

pub LitType: LitType = {
    "Int" => LitType::TyInt,
    "Float" => LitType::TyFloat,
    "Char" => LitType::TyChar,
    "Bool" => LitType::TyBool,
};

pub Prim: Prim = {
    "@iadd" => Prim::IAdd,
    "@isub" => Prim::ISub,
    "@imul" => Prim::IMul,
}

Comma<T>: Vec<T> = {
    <mut xs: (<T> ",")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            xs.push(x);
            xs
        }
    }
};

pub Program: Program = {
    <decls: Declaration*> => {
        let mut datas = Vec::new();
        let mut funcs = Vec::new();
        for decl in decls.into_iter() {
            match decl {
                Declaration::Data(data) => { datas.push(data); }
                Declaration::Func(func) => { funcs.push(func); }
            }
        }
        Program { datas, funcs }
    },  
}

pub Declaration: Declaration = {
    <data: DataDecl> => Declaration::Data(data),
    <func: FuncDecl> => Declaration::Func(func),
}

pub FuncDecl: FuncDecl = {
    "function" <name: LId> "(" <pars: Comma<(<LId> ":" <Type>)>> ")" "->" <res: Type>
        "begin" <body: Expr> "end" =>
            FuncDecl { name, pars, res, body },
}

pub DataDecl: DataDecl = {
    "datatype" <name: UId> "where" <cons: ("|" <Constructor>)* > "end" =>
        DataDecl { name, cons },
}

pub Constructor: Constructor = {
    <name: UId> =>
        Constructor { name, flds: Vec::new() },
    <name: UId> "{" <flds: Comma<(<LId> ":" <Type>)>> "}" =>
        Constructor { name, flds },
}

pub Type: Type = {
    <lit: LitType> => Type::Lit(lit),
    <data: UId> => Type::Data(data),
}

pub Expr: Expr = {
    <lit: LitVal> => Expr::Lit { lit },
    <var: LId>  => Expr::Var { var },
    <prim: Prim> "(" <args: Comma<Expr>> ")" =>
        Expr::Prim { prim, args},
    <name: UId> =>
        Expr::Cons { name, flds: Vec::new() },
    <name: UId> "{" <flds: Comma<(<LId> ":" <Expr>)>> "}" =>
        Expr::Cons { name, flds },
    <var: LId> "." <fld: LId> =>
        Expr::Fld { var, fld },
    "match" <expr: Expr> "as" <bind: LId> "with" <brchs: ("|" <UId> "=>" <Expr>)*> "end" =>
        Expr::Match { expr: Box::new(expr), bind, brchs },
    "let" <bind: LId> "=" <body: Expr> ";" <cont: Expr> =>
        Expr::Let { bind, body: Box::new(body), cont: Box::new(cont)},
    <var: LId> "(" <args: Comma<Expr>> ")" =>
        Expr::App { func: var, args },
    "(" <expr: Expr> ")" =>
        expr,
}
