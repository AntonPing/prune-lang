use crate::utils::ident::Ident;
use crate::utils::intern::InternStr;
use crate::utils::lit::{LitType, LitVal};
use crate::utils::prim::{Prim, Compare};
use crate::syntax::ast::*;

use std::str::FromStr;

grammar;

pub Nat: usize = <s:r"[0-9]+"> => usize::from_str(s).unwrap();
pub Int: i64 = {
    <n: Nat> => n as i64,
    "-" <n: Nat> => - (n as i64),
}
pub Float: f64 = <s:r"(-)?[0-9]+\.[0-9]+"> => f64::from_str(s).unwrap();
pub Bool: bool = {
    "false" => false,
    "true" => true,
};
pub Char: char = <s:r"'.'"> => char::from_str(&s[1..2]).unwrap();

pub LId: Ident = <s:r"[_a-z][_a-zA-Z0-9]*"> => Ident::dummy(&InternStr::new(s));
pub UId: Ident = <s:r"[A-Z][_a-zA-Z0-9]*"> => Ident::dummy(&InternStr::new(s));

pub LitVal: LitVal = {
    <x: Int> => LitVal::Int(x),
    <x: Float> => LitVal::Float(x),
    <x: Char> => LitVal::Char(x),
    <x: Bool> => LitVal::Bool(x),
};

pub LitType: LitType = {
    "Int" => LitType::TyInt,
    "Float" => LitType::TyFloat,
    "Char" => LitType::TyChar,
    "Bool" => LitType::TyBool,
};

pub Prim: Prim = {
    "@iadd" => Prim::IAdd,
    "@isub" => Prim::ISub,
    "@imul" => Prim::IMul,
    "@idiv" => Prim::IDiv,
    "@irem" => Prim::IRem,
    "@ineg" => Prim::INeg,
    "@icmplt" => Prim::ICmp(Compare::Lt),
    "@icmple" => Prim::ICmp(Compare::Le),
    "@icmpeq" => Prim::ICmp(Compare::Eq),
    "@icmpgt" => Prim::ICmp(Compare::Gt),
    "@icmpge" => Prim::ICmp(Compare::Ge),
    "@icmpne" => Prim::ICmp(Compare::Ne),
    "@band" => Prim::BAnd,
    "@bor" => Prim::BOr,
    "@bnot" => Prim::BNot,
}

Comma<T>: Vec<T> = {
    <mut xs: (<T> ",")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            xs.push(x);
            xs
        }
    }
};

Semi<T>: Vec<T> = {
    <mut xs: (<T> ";")*> <x: T?> => match x {
        None => xs,
        Some(x) => {
            xs.push(x);
            xs
        }
    }
};

pub Program: Program = {
    <decls: Declaration*> => {
        let mut datas = Vec::new();
        let mut funcs = Vec::new();
        let mut preds = Vec::new();
        for decl in decls.into_iter() {
            match decl {
                Declaration::Data(data) => { datas.push(data); }
                Declaration::Func(func) => { funcs.push(func); }
                Declaration::Pred(pred) => { preds.push(pred); }
            }
        }
        Program { datas, funcs, preds }
    },  
}

pub Declaration: Declaration = {
    <data: DataDecl> => Declaration::Data(data),
    <func: FuncDecl> => Declaration::Func(func),
    <pred: PredDecl> => Declaration::Pred(pred),
}

pub FuncDecl: FuncDecl = {
    "function" <name: LId> "(" <pars: Comma<(<LId> ":" <Type>)>> ")" "->" <res: Type>
        "begin" <body: Expr> "end" =>
            FuncDecl { name, pars, res, body },
}

pub DataDecl: DataDecl = {
    "datatype" <name: UId> "where" <cons: ("|" <Constructor>)* > "end" =>
        DataDecl { name, cons },
}

pub PredDecl: PredDecl = {
    "predicate" <name: LId> "(" <pars: Comma<(<LId> ":" <Type>)>> ")" 
        "begin" <body: GoalSeq> "end" =>
            PredDecl { name, pars, body },
}

pub Constructor: Constructor = {
    <name: UId> =>
        Constructor { name, flds: Vec::new() },
    <name: UId> "(" <flds: Comma<Type>> ")" =>
        Constructor { name, flds },
}

pub Type: Type = {
    <lit: LitType> => Type::Lit(lit),
    <data: UId> => Type::Data(data),
}

pub Pattern: Pattern = {
    <name: UId> =>
        Pattern { name, flds: Vec::new() },
    <name: UId> "(" <flds: Comma<LId>> ")" =>
        Pattern { name, flds },
}

pub Expr: Expr = {
    <lit: LitVal> => Expr::Lit { lit },
    <var: LId>  => Expr::Var { var },
    <prim: Prim> "(" <args: Comma<Expr>> ")" =>
        Expr::Prim { prim, args},
    <name: UId> =>
        Expr::Cons { name, flds: Vec::new() },
    <name: UId> "(" <flds: Comma<Expr>> ")" =>
        Expr::Cons { name, flds },
    "match" <expr: Expr> "with" <brchs: ("|" <Pattern> "=>" <Expr>)*> "end" =>
        Expr::Match { expr: Box::new(expr), brchs },
    "let" <bind: LId> "=" <expr: Expr> ";" <cont: Expr> =>
        Expr::Let { bind, expr: Box::new(expr), cont: Box::new(cont)},
    <func: LId> "(" <args: Comma<Expr>> ")" =>
        Expr::App { func, args },
    "if" <cond: Expr> "then" <then: Expr> "else" <els: Expr> =>
        Expr::Ifte { cond: Box::new(cond), then: Box::new(then), els: Box::new(els) },
    "assert" <expr: Expr> ";" <cont: Expr> =>
        Expr::Assert { expr: Box::new(expr), cont: Box::new(cont) },
    "(" <expr: Expr> ")" =>
        expr,
}

pub Goal: Goal = {
    "fresh" "(" <vars: Comma<LId>> ")" "(" <body: GoalSeq> ")" =>
        Goal::Fresh { vars, body: Box::new(body) },
    <lhs: Expr> "=" <rhs: Expr> =>
        Goal::Eq { lhs, rhs },
    "fail" <expr: Expr> => 
        Goal::Fail { expr },
    "and" "(" <goals: Comma<Goal>> ")" =>
        Goal::And { goals },
    "or" "(" <goals: Comma<Goal>> ")" =>
        Goal::Or { goals },
    "@" <pred: LId> "(" <args: Comma<Expr>> ")" =>
        Goal::Pred{ pred, args },
    "cond" <goals: ("|" <GoalSeq>)+> "end" => {
        if goals.len() == 1 {
            goals.into_iter().nth(0).unwrap()
        } else {
            Goal::Or { goals }
        }
    },
    "(" <goal: GoalSeq> ")" => {
        goal
    }
}

pub GoalSeq : Goal = {
    <goals: Semi<Goal>> => {
        if goals.len() == 1 {
            goals.into_iter().nth(0).unwrap()
        } else {
            Goal::And { goals }
        }
    }
}